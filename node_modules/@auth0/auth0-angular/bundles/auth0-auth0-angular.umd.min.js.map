{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/auth0-angular/src/useragent.ts","../../projects/auth0-angular/src/lib/auth.client.ts","../../projects/auth0-angular/src/lib/abstract-navigator.ts","../../projects/auth0-angular/src/lib/auth.config.ts","../../projects/auth0-angular/src/lib/auth.service.ts","../../projects/auth0-angular/src/lib/auth.guard.ts","../../projects/auth0-angular/src/lib/auth.module.ts","../../projects/auth0-angular/src/lib/auth.interceptor.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","useragent","Auth0ClientFactory","createClient","configFactory","config","get","Error","redirectUri","clientId","maxAge","rest","httpInterceptor","s","t","p","prototype","hasOwnProperty","indexOf","getOwnPropertySymbols","length","propertyIsEnumerable","__rest","Auth0Client","assign","redirect_uri","window","location","origin","client_id","max_age","auth0Client","name","version","Auth0ClientService","InjectionToken","AbstractNavigator","injector","this","router","Router","_a","navigateByUrl","url","replaceState","isHttpInterceptorRouteConfig","def","Injectable","args","providedIn","Location","Injector","AuthClientConfig","set","Optional","type","Inject","AuthConfigService","AuthService","navigator","_this","isLoadingSubject$","BehaviorSubject","errorSubject$","ReplaySubject","refreshState$","Subject","accessToken$","ngUnsubscribe$","isLoading$","asObservable","accessTokenTrigger$","pipe","scan","acc","current","previous","filter","_c","isAuthenticatedTrigger$","loading","distinctUntilChanged","switchMap","merge","defer","isAuthenticated","mergeMap","isAuthenticated$","user$","concatMap","authenticated","getUser","of","idTokenClaims$","getIdTokenClaims","error$","shouldHandleCallback","isCallback","iif","handleRedirectCallback","checkSession","checkSessionOrCallback$","catchError","errorPath","undefined","tap","takeUntil","subscribe","ngOnDestroy","complete","loginWithRedirect","options","from","loginWithPopup","then","logout","localOnly","getAccessTokenSilently","client","getTokenSilently","token","throwError","getAccessTokenWithPopup","getTokenWithPopup","withLatestFrom","_d","result","target","_b","appState","map","buildAuthorizeUrl","buildLogoutUrl","path","search","includes","skipRedirectCallback","decorators","AuthGuard","auth","canLoad","route","segments","take","canActivate","state","redirectIfUnauthenticated","canActivateChild","childRoute","loggedIn","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","NgModule","AuthHttpInterceptor","authService","intercept","req","allowedList","findMatchingRoute","pluck","err","allowAnonymous","clone","headers","handle","stripQueryFrom","uri","substr","canAttachToken","request","testPrimitive","startsWith","httpMethod","method","uriMatcher","console","warn","first"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export default { name: '@auth0/auth0-angular', version: '1.5.0' };\n","import { InjectionToken } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport { AuthClientConfig } from './auth.config';\nimport useragent from '../useragent';\n\nexport class Auth0ClientFactory {\n  static createClient(configFactory: AuthClientConfig): Auth0Client {\n    const config = configFactory.get();\n\n    if (!config) {\n      throw new Error(\n        'Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set'\n      );\n    }\n\n    const { redirectUri, clientId, maxAge, httpInterceptor, ...rest } = config;\n\n    return new Auth0Client({\n      redirect_uri: redirectUri || window.location.origin,\n      client_id: clientId,\n      max_age: maxAge,\n      ...rest,\n      auth0Client: {\n        name: useragent.name,\n        version: useragent.version,\n      },\n    });\n  }\n}\n\nexport const Auth0ClientService = new InjectionToken<Auth0Client>(\n  'auth0.client'\n);\n","import { Injectable, Injector } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Location } from '@angular/common';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AbstractNavigator {\n  private readonly router?: Router;\n\n  constructor(private location: Location, injector: Injector) {\n    try {\n      this.router = injector.get(Router);\n    } catch {}\n  }\n\n  /**\n   * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n   * to `window.history.replaceState`.\n   * @param url The url to navigate to\n   */\n  navigateByUrl(url: string): void {\n    if (this.router) {\n      this.router.navigateByUrl(url);\n\n      return;\n    }\n\n    this.location.replaceState(url);\n  }\n}\n","import { CacheLocation, GetTokenSilentlyOptions } from '@auth0/auth0-spa-js';\nimport { InjectionToken, Injectable, Optional, Inject } from '@angular/core';\n\n/**\n * Defines a common set of HTTP methods.\n */\nexport const enum HttpMethod {\n  Get = 'GET',\n  Post = 'POST',\n  Put = 'PUT',\n  Patch = 'PATCH',\n  Delete = 'DELETE',\n  Head = 'HEAD',\n}\n\n/**\n * Defines the type for a route config entry. Can either be:\n *\n * - an object of type HttpInterceptorRouteConfig\n * - a string\n */\nexport type ApiRouteDefinition = HttpInterceptorRouteConfig | string;\n\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\nexport function isHttpInterceptorRouteConfig(\n  def: ApiRouteDefinition\n): def is HttpInterceptorRouteConfig {\n  return typeof def !== 'string';\n}\n\n/**\n * Configuration for the HttpInterceptor\n */\nexport interface HttpInterceptorConfig {\n  allowedList: ApiRouteDefinition[];\n}\n\n/**\n * Configuration for a single interceptor route\n */\nexport interface HttpInterceptorRouteConfig {\n  /**\n   * The URL to test, by supplying the URL to match.\n   * If `test` is a match for the current request path from the HTTP client, then\n   * an access token is attached to the request in the\n   *  [\"Authorization\" header](https://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-20#section-2.1).\n   *\n   * If the test does not pass, the request proceeds without the access token attached.\n   *\n   * A wildcard character can be used to match only the start of the URL.\n   *\n   * @usagenotes\n   *\n   * '/api' - exactly match the route /api\n   * '/api/*' - match any route that starts with /api/\n   */\n  uri?: string;\n\n  /**\n   * A function that will be called with the HttpRequest.url value, allowing you to do\n   * any kind of flexible matching.\n   *\n   * If this function returns true, then\n   * an access token is attached to the request in the\n   *  [\"Authorization\" header](https://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-20#section-2.1).\n   *\n   * If it returns false, the request proceeds without the access token attached.\n   */\n  uriMatcher?: (uri: string) => boolean;\n\n  /**\n   * The options that are passed to the SDK when retrieving the\n   * access token to attach to the outgoing request.\n   */\n  tokenOptions?: GetTokenSilentlyOptions;\n\n  /**\n   * The HTTP method to match on. If specified, the HTTP method of\n   * the outgoing request will be checked against this. If there is no match, the\n   * Authorization header is not attached.\n   *\n   * The HTTP method name is case-sensitive.\n   */\n  httpMethod?: HttpMethod | string;\n\n  /**\n   * Allow the HTTP call to be executed anonymously, when no token is available.\n   *\n   * When omitted (or set to false), calls that match the configuration will fail when no token is available.\n   */\n  allowAnonymous?: boolean;\n}\n\n/**\n * Configuration for the authentication service\n */\nexport interface AuthConfig {\n  /**\n   * Your Auth0 account domain such as `'example.auth0.com'`,\n   * `'example.eu.auth0.com'` or , `'example.mycompany.com'`\n   * (when using [custom domains](https://auth0.com/docs/custom-domains))\n   */\n  domain: string;\n\n  /**\n   * The issuer to be used for validation of JWTs, optionally defaults to the domain above\n   */\n  issuer?: string;\n\n  /**\n   * The Client ID found on your Application settings page\n   */\n  clientId: string;\n\n  /**\n   * The default URL where Auth0 will redirect your browser to with\n   * the authentication result. It must be added to the\n   * \"Allowed Callback URLs\" field in your Auth0 Application's\n   * settings. If not provided here, it should be provided in the other\n   * methods that provide authentication.\n   */\n  redirectUri?: string;\n\n  /**\n   * By default, if the page URL has code and state parameters, the SDK will assume they are for\n   * an Auth0 application and attempt to exchange the code for a token.\n   * In some cases the code might be for something else (e.g. another OAuth SDK). In these\n   * instances you can instruct the client to ignore them by setting `skipRedirectCallback`.\n   *\n   * ```js\n   * AuthModule.forRoot({\n   *   skipRedirectCallback: window.location.pathname === '/other-callback'\n   * })\n   * ```\n   *\n   * **Note**: In the above example, `/other-callback` is an existing route that will be called\n   * by any other OAuth provider with a `code` (or `error` in case when something went wrong) and `state`.\n   *\n   */\n  skipRedirectCallback?: boolean;\n\n  /**\n   * The value in seconds used to account for clock skew in JWT expirations.\n   * Typically, this value is no more than a minute or two at maximum.\n   * Defaults to 60s.\n   */\n  leeway?: number;\n\n  /**\n   * The location to use when storing cache data. Valid values are `memory` or `localstorage`.\n   * The default setting is `memory`.\n   */\n  cacheLocation?: CacheLocation;\n\n  /**\n   * If true, refresh tokens are used to fetch new access tokens from the Auth0 server.\n   * If false, the legacy technique of using a hidden iframe and the `authorization_code` grant with `prompt=none` is used.\n   * The default setting is `false`.\n   *\n   * **Note**: Use of refresh tokens must be enabled by an administrator on your Auth0 client application.\n   */\n  useRefreshTokens?: boolean;\n\n  /**\n   * A maximum number of seconds to wait before declaring background calls to /authorize as failed for timeout\n   * Defaults to 60s.\n   */\n  authorizeTimeoutInSeconds?: number;\n\n  /**\n   * Changes to recommended defaults, like defaultScope\n   */\n  advancedOptions?: {\n    /**\n     * The default scope to be included with all requests.\n     * If not provided, 'openid profile email' is used. This can be set to `null` in order to effectively remove the default scopes.\n     *\n     * Note: The `openid` scope is **always applied** regardless of this setting.\n     */\n    defaultScope?: string;\n  };\n\n  /**\n   * Maximum allowable elapsed time (in seconds) since authentication.\n   * If the last time the user authenticated is greater than this value,\n   * the user must be reauthenticated.\n   */\n  maxAge?: string | number;\n\n  /**\n   * The default scope to be used on authentication requests.\n   * The defaultScope defined in the Auth0Client is included\n   * along with this scope\n   */\n  scope?: string;\n\n  /**\n   * The default audience to be used for requesting API access.\n   */\n  audience?: string;\n\n  /**\n   * Configuration for the built-in Http Interceptor, used for\n   * automatically attaching access tokens.\n   */\n  httpInterceptor?: HttpInterceptorConfig;\n\n  /**\n   * Path in your application to redirect to when the Authorization server\n   * returns an error. Defaults to `/`\n   */\n  errorPath?: string;\n\n  /**\n   * The Id of an organization to log in to\n   *\n   * This will specify an `organization` parameter in your user's login request and will add a step to validate\n   * the `org_id` claim in your user's ID Token.\n   */\n  organization?: string;\n\n  /**\n   * The Id of an invitation to accept.\n   *\n   * This is available from the user invitation URL that is given when participating in a user invitation flow.\n   */\n  invitation?: string;\n\n  /**\n   * If you need to send custom parameters to the Authorization Server,\n   * make sure to use the original parameter name.\n   */\n  [key: string]: any;\n}\n\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\n@Injectable({ providedIn: 'root' })\nexport class AuthClientConfig {\n  private config?: AuthConfig;\n\n  constructor(@Optional() @Inject(AuthConfigService) config?: AuthConfig) {\n    if (config) {\n      this.set(config);\n    }\n  }\n\n  /**\n   * Sets configuration to be read by other consumers of the service (see usage notes)\n   * @param config The configuration to set\n   */\n  set(config: AuthConfig): void {\n    this.config = config;\n  }\n\n  /**\n   * Gets the config that has been set by other consumers of the service\n   */\n  get(): AuthConfig {\n    return this.config as AuthConfig;\n  }\n}\n\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\nexport const AuthConfigService = new InjectionToken<AuthConfig>(\n  'auth0-angular.config'\n);\n","import { Injectable, Inject, OnDestroy } from '@angular/core';\n\nimport {\n  Auth0Client,\n  RedirectLoginOptions,\n  PopupLoginOptions,\n  PopupConfigOptions,\n  LogoutOptions,\n  GetTokenSilentlyOptions,\n  GetTokenWithPopupOptions,\n  RedirectLoginResult,\n  LogoutUrlOptions,\n} from '@auth0/auth0-spa-js';\n\nimport {\n  of,\n  from,\n  BehaviorSubject,\n  Subject,\n  Observable,\n  iif,\n  defer,\n  ReplaySubject,\n  merge,\n  throwError,\n} from 'rxjs';\n\nimport {\n  concatMap,\n  tap,\n  map,\n  filter,\n  takeUntil,\n  distinctUntilChanged,\n  catchError,\n  switchMap,\n  mergeMap,\n  scan,\n  withLatestFrom,\n} from 'rxjs/operators';\n\nimport { Auth0ClientService } from './auth.client';\nimport { AbstractNavigator } from './abstract-navigator';\nimport { Location } from '@angular/common';\nimport { AuthClientConfig } from './auth.config';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService implements OnDestroy {\n  private isLoadingSubject$ = new BehaviorSubject<boolean>(true);\n  private errorSubject$ = new ReplaySubject<Error>(1);\n  private refreshState$ = new Subject<void>();\n  private accessToken$ = new ReplaySubject<string>(1);\n\n  // https://stackoverflow.com/a/41177163\n  private ngUnsubscribe$ = new Subject<void>();\n  /**\n   * Emits boolean values indicating the loading state of the SDK.\n   */\n  readonly isLoading$ = this.isLoadingSubject$.asObservable();\n\n  /**\n   * Trigger used to pull User information from the Auth0Client.\n   * Triggers when the access token has changed.\n   */\n  private accessTokenTrigger$ = this.accessToken$.pipe(\n    scan(\n      (\n        acc: { current: string | null; previous: string | null },\n        current: string | null\n      ) => {\n        return {\n          previous: acc.current,\n          current,\n        };\n      },\n      { current: null, previous: null }\n    ),\n    filter(({ previous, current }) => previous !== current)\n  );\n\n  /**\n   * Trigger used to pull User information from the Auth0Client.\n   * Triggers when an event occurs that needs to retrigger the User Profile information.\n   * Events: Login, Access Token change and Logout\n   */\n  private isAuthenticatedTrigger$ = this.isLoading$.pipe(\n    filter((loading) => !loading),\n    distinctUntilChanged(),\n    switchMap(() =>\n      // To track the value of isAuthenticated over time, we need to merge:\n      //  - the current value\n      //  - the value whenever the access token changes. (this should always be true of there is an access token\n      //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n      //  - the value whenever refreshState$ emits\n      merge(\n        defer(() => this.auth0Client.isAuthenticated()),\n        this.accessTokenTrigger$.pipe(\n          mergeMap(() => this.auth0Client.isAuthenticated())\n        ),\n        this.refreshState$.pipe(\n          mergeMap(() => this.auth0Client.isAuthenticated())\n        )\n      )\n    )\n  );\n\n  /**\n   * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n   * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n   */\n  readonly isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(\n    distinctUntilChanged()\n  );\n\n  /**\n   * Emits details about the authenticated user, or null if not authenticated.\n   */\n  readonly user$ = this.isAuthenticatedTrigger$.pipe(\n    concatMap((authenticated) =>\n      authenticated ? this.auth0Client.getUser() : of(null)\n    )\n  );\n\n  /**\n   * Emits ID token claims when authenticated, or null if not authenticated.\n   */\n  readonly idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(\n    concatMap((authenticated) =>\n      authenticated ? this.auth0Client.getIdTokenClaims() : of(null)\n    )\n  );\n\n  /**\n   * Emits errors that occur during login, or when checking for an active session on startup.\n   */\n  readonly error$ = this.errorSubject$.asObservable();\n\n  constructor(\n    @Inject(Auth0ClientService) private auth0Client: Auth0Client,\n    private configFactory: AuthClientConfig,\n    private location: Location,\n    private navigator: AbstractNavigator\n  ) {\n    const checkSessionOrCallback$ = (isCallback: boolean) =>\n      iif(\n        () => isCallback,\n        this.handleRedirectCallback(),\n        defer(() => this.auth0Client.checkSession())\n      );\n\n    this.shouldHandleCallback()\n      .pipe(\n        switchMap((isCallback) =>\n          checkSessionOrCallback$(isCallback).pipe(\n            catchError((error) => {\n              const config = this.configFactory.get();\n              this.errorSubject$.next(error);\n              this.navigator.navigateByUrl(config.errorPath || '/');\n              return of(undefined);\n            })\n          )\n        ),\n        tap(() => {\n          this.isLoadingSubject$.next(false);\n        }),\n        takeUntil(this.ngUnsubscribe$)\n      )\n      .subscribe();\n  }\n\n  /**\n   * Called when the service is destroyed\n   */\n  ngOnDestroy(): void {\n    // https://stackoverflow.com/a/41177163\n    this.ngUnsubscribe$.next();\n    this.ngUnsubscribe$.complete();\n  }\n\n  /**\n   * ```js\n   * loginWithRedirect(options);\n   * ```\n   *\n   * Performs a redirect to `/authorize` using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated.\n   *\n   * @param options The login options\n   */\n  loginWithRedirect(options?: RedirectLoginOptions): Observable<void> {\n    return from(this.auth0Client.loginWithRedirect(options));\n  }\n\n  /**\n   * ```js\n   * await loginWithPopup(options);\n   * ```\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   *\n   * IMPORTANT: This method has to be called from an event handler\n   * that was started by the user like a button click, for example,\n   * otherwise the popup will be blocked in most browsers.\n   *\n   * @param options The login options\n   * @param config Configuration for the popup window\n   */\n  loginWithPopup(\n    options?: PopupLoginOptions,\n    config?: PopupConfigOptions\n  ): Observable<void> {\n    return from(\n      this.auth0Client.loginWithPopup(options, config).then(() => {\n        this.refreshState$.next();\n      })\n    );\n  }\n\n  /**\n   * ```js\n   * logout();\n   * ```\n   *\n   * Clears the application session and performs a redirect to `/v2/logout`, using\n   * the parameters provided as arguments, to clear the Auth0 session.\n   * If the `federated` option is specified it also clears the Identity Provider session.\n   * If the `localOnly` option is specified, it only clears the application session.\n   * It is invalid to set both the `federated` and `localOnly` options to `true`,\n   * and an error will be thrown if you do.\n   * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n   *\n   * @param options The logout options\n   */\n  logout(options?: LogoutOptions): void {\n    this.auth0Client.logout(options);\n\n    if (options?.localOnly) {\n      this.refreshState$.next();\n    }\n  }\n\n  /**\n   * ```js\n   * getAccessTokenSilently(options).subscribe(token => ...)\n   * ```\n   *\n   * If there's a valid token stored, return it. Otherwise, opens an\n   * iframe with the `/authorize` URL using the parameters provided\n   * as arguments. Random and secure `state` and `nonce` parameters\n   * will be auto-generated. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * If refresh tokens are used, the token endpoint is called directly with the\n   * 'refresh_token' grant. If no refresh token is available to make this call,\n   * the SDK falls back to using an iframe to the '/authorize' URL.\n   *\n   * This method may use a web worker to perform the token call if the in-memory\n   * cache is used.\n   *\n   * If an `audience` value is given to this function, the SDK always falls\n   * back to using an iframe to make the token exchange.\n   *\n   * Note that in all cases, falling back to an iframe requires access to\n   * the `auth0` cookie, and thus will not work in browsers that block third-party\n   * cookies by default (Safari, Brave, etc).\n   *\n   * @param options The options for configuring the token fetch.\n   */\n  getAccessTokenSilently(\n    options?: GetTokenSilentlyOptions\n  ): Observable<string> {\n    return of(this.auth0Client).pipe(\n      concatMap((client) => client.getTokenSilently(options)),\n      tap((token) => this.accessToken$.next(token)),\n      catchError((error) => {\n        this.errorSubject$.next(error);\n        this.refreshState$.next();\n        return throwError(error);\n      })\n    );\n  }\n\n  /**\n   * ```js\n   * getTokenWithPopup(options).subscribe(token => ...)\n   * ```\n   *\n   * Get an access token interactively.\n   *\n   * Opens a popup with the `/authorize` URL using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated. If the response is successful,\n   * results will be valid according to their expiration times.\n   */\n  getAccessTokenWithPopup(\n    options?: GetTokenWithPopupOptions\n  ): Observable<string> {\n    return of(this.auth0Client).pipe(\n      concatMap((client) => client.getTokenWithPopup(options)),\n      tap((token) => this.accessToken$.next(token)),\n      catchError((error) => {\n        this.errorSubject$.next(error);\n        this.refreshState$.next();\n        return throwError(error);\n      })\n    );\n  }\n\n  /**\n   * ```js\n   * handleRedirectCallback(url).subscribe(result => ...)\n   * ```\n   *\n   * After the browser redirects back to the callback page,\n   * call `handleRedirectCallback` to handle success and error\n   * responses from Auth0. If the response is successful, results\n   * will be valid according to their expiration times.\n   *\n   * Calling this method also refreshes the authentication and user states.\n   *\n   * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n   */\n  handleRedirectCallback(url?: string): Observable<RedirectLoginResult> {\n    return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(\n      withLatestFrom(this.isLoadingSubject$),\n      tap(([result, isLoading]) => {\n        if (!isLoading) {\n          this.refreshState$.next();\n        }\n        const target = result?.appState?.target ?? '/';\n        this.navigator.navigateByUrl(target);\n      }),\n      map(([result]) => result)\n    );\n  }\n\n  /**\n   * ```js\n   * buildAuthorizeUrl().subscribe(url => ...)\n   * ```\n   *\n   * Builds an `/authorize` URL for loginWithRedirect using the parameters\n   * provided as arguments. Random and secure `state` and `nonce`\n   * parameters will be auto-generated.\n   * @param options The options\n   * @returns A URL to the authorize endpoint\n   */\n  buildAuthorizeUrl(options?: RedirectLoginOptions): Observable<string> {\n    return defer(() => this.auth0Client.buildAuthorizeUrl(options));\n  }\n\n  /**\n   * ```js\n   * buildLogoutUrl().subscribe(url => ...)\n   * ```\n   * Builds a URL to the logout endpoint.\n   *\n   * @param options The options used to configure the parameters that appear in the logout endpoint URL.\n   * @returns a URL to the logout endpoint using the parameters provided as arguments.\n   */\n  buildLogoutUrl(options?: LogoutUrlOptions): Observable<string> {\n    return of(this.auth0Client.buildLogoutUrl(options));\n  }\n\n  private shouldHandleCallback(): Observable<boolean> {\n    return of(this.location.path()).pipe(\n      map((search) => {\n        return (\n          (search.includes('code=') || search.includes('error=')) &&\n          search.includes('state=') &&\n          !this.configFactory.get().skipRedirectCallback\n        );\n      })\n    );\n  }\n}\n","import { Injectable } from '@angular/core';\nimport {\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot,\n  CanActivate,\n  CanLoad,\n  Route,\n  UrlSegment,\n  CanActivateChild,\n} from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { tap, take } from 'rxjs/operators';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate, CanLoad, CanActivateChild {\n  constructor(private auth: AuthService) {}\n\n  canLoad(route: Route, segments: UrlSegment[]): Observable<boolean> {\n    return this.auth.isAuthenticated$.pipe(take(1));\n  }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.redirectIfUnauthenticated(state);\n  }\n\n  canActivateChild(\n    childRoute: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.redirectIfUnauthenticated(state);\n  }\n\n  private redirectIfUnauthenticated(\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.auth.isAuthenticated$.pipe(\n      tap((loggedIn) => {\n        if (!loggedIn) {\n          this.auth.loginWithRedirect({\n            appState: { target: state.url },\n          });\n        }\n      })\n    );\n  }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { AuthService } from './auth.service';\nimport { AuthConfig, AuthConfigService, AuthClientConfig } from './auth.config';\nimport { Auth0ClientService, Auth0ClientFactory } from './auth.client';\nimport { AuthGuard } from './auth.guard';\n\n@NgModule()\nexport class AuthModule {\n  /**\n   * Initialize the authentication module system. Configuration can either be specified here,\n   * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n   * @param config The optional configuration for the SDK.\n   */\n  static forRoot(config?: AuthConfig): ModuleWithProviders<AuthModule> {\n    return {\n      ngModule: AuthModule,\n      providers: [\n        AuthService,\n        AuthGuard,\n        {\n          provide: AuthConfigService,\n          useValue: config,\n        },\n        {\n          provide: Auth0ClientService,\n          useFactory: Auth0ClientFactory.createClient,\n          deps: [AuthClientConfig],\n        },\n      ],\n    };\n  }\n}\n","import {\n  HttpInterceptor,\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n} from '@angular/common/http';\n\nimport { Observable, from, of, iif, throwError } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\nimport {\n  ApiRouteDefinition,\n  isHttpInterceptorRouteConfig,\n  AuthClientConfig,\n  HttpInterceptorConfig,\n} from './auth.config';\n\nimport { switchMap, first, concatMap, pluck, catchError } from 'rxjs/operators';\nimport { AuthService } from './auth.service';\nimport { GetTokenSilentlyOptions } from '@auth0/auth0-spa-js';\n\n@Injectable()\nexport class AuthHttpInterceptor implements HttpInterceptor {\n  constructor(\n    private configFactory: AuthClientConfig,\n    private authService: AuthService\n  ) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const config = this.configFactory.get();\n    if (!config.httpInterceptor?.allowedList) {\n      return next.handle(req);\n    }\n\n    return this.findMatchingRoute(req, config.httpInterceptor).pipe(\n      concatMap((route) =>\n        iif(\n          // Check if a route was matched\n          () => route !== null,\n          // If we have a matching route, call getTokenSilently and attach the token to the\n          // outgoing request\n          of(route).pipe(\n            pluck('tokenOptions'),\n            concatMap<GetTokenSilentlyOptions, Observable<string>>((options) =>\n              this.authService.getAccessTokenSilently(options).pipe(\n                catchError((err) => {\n                  if (this.allowAnonymous(route, err)) {\n                    return of('');\n                  }\n\n                  return throwError(err);\n                })\n              )\n            ),\n            switchMap((token: string) => {\n              // Clone the request and attach the bearer token\n              const clone = token\n                ? req.clone({\n                    headers: req.headers.set(\n                      'Authorization',\n                      `Bearer ${token}`\n                    ),\n                  })\n                : req;\n\n              return next.handle(clone);\n            })\n          ),\n          // If the URI being called was not found in our httpInterceptor config, simply\n          // pass the request through without attaching a token\n          next.handle(req)\n        )\n      )\n    );\n  }\n\n  /**\n   * Strips the query and fragment from the given uri\n   * @param uri The uri to remove the query and fragment from\n   */\n  private stripQueryFrom(uri: string): string {\n    if (uri.indexOf('?') > -1) {\n      uri = uri.substr(0, uri.indexOf('?'));\n    }\n\n    if (uri.indexOf('#') > -1) {\n      uri = uri.substr(0, uri.indexOf('#'));\n    }\n\n    return uri;\n  }\n\n  /**\n   * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n   * the interceptor route configuration.\n   * @param route The route to test\n   * @param request The HTTP request\n   */\n  private canAttachToken(\n    route: ApiRouteDefinition,\n    request: HttpRequest<any>\n  ): boolean {\n    const testPrimitive = (value: string | undefined): boolean => {\n      if (!value) {\n        return false;\n      }\n\n      const requestPath = this.stripQueryFrom(request.url);\n\n      if (value === requestPath) {\n        return true;\n      }\n\n      // If the URL ends with an asterisk, match using startsWith.\n      return (\n        value.indexOf('*') === value.length - 1 &&\n        request.url.startsWith(value.substr(0, value.length - 1))\n      );\n    };\n\n    if (isHttpInterceptorRouteConfig(route)) {\n      if (route.httpMethod && route.httpMethod !== request.method) {\n        return false;\n      }\n\n      /* istanbul ignore if */\n      if (!route.uri && !route.uriMatcher) {\n        console.warn(\n          'Either a uri or uriMatcher is required when configuring the HTTP interceptor.'\n        );\n      }\n\n      return route.uriMatcher\n        ? route.uriMatcher(request.url)\n        : testPrimitive(route.uri);\n    }\n\n    return testPrimitive(route);\n  }\n\n  /**\n   * Tries to match a route from the SDK configuration to the HTTP request.\n   * If a match is found, the route configuration is returned.\n   * @param request The Http request\n   * @param config HttpInterceptorConfig\n   */\n  private findMatchingRoute(\n    request: HttpRequest<any>,\n    config: HttpInterceptorConfig\n  ): Observable<ApiRouteDefinition | null> {\n    return from(config.allowedList).pipe(\n      first((route) => this.canAttachToken(route, request), null)\n    );\n  }\n\n  private allowAnonymous(route: ApiRouteDefinition | null, err: any): boolean {\n    return (\n      !!route &&\n      isHttpInterceptorRouteConfig(route) &&\n      !!route.allowAnonymous &&\n      ['login_required', 'consent_required'].includes(err.error)\n    );\n  }\n}\n"]}